{% load static %}
{% load i18n %}
{% load rules %}
{% load filters %}

<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8"/>
  <meta name="author" content="Label Studio"/>
  <meta http-equiv="Content-Type" content="text/html;charset=utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=0.9, shrink-to-fit=no">

  <!-- Address string color -->
  <meta name="theme-color" content="#272727"> <!-- Chrome, Firefox OS and Opera -->
  <meta name="msapplication-navbutton-color" content="#272727">  <!-- Windows Phone -->
  <meta name="apple-mobile-web-app-status-bar-style" content="#272727">  <!-- iOS Safari -->

  <!-- CSS -->
  {% block app-css %}
    <link href="{{settings.FRONTEND_HOSTNAME}}/react-app/main.css?v={{ versions.backend.commit }}" rel="stylesheet">
  {% endblock %}

  {% block theme_colors %}
    {% if feature_flags.fflag_feat_front_optic_1217_theme_toggle_short %}
    <script>
      function handleThemeColor() {
        let themeColor = window.localStorage.getItem("preferred-color-scheme");
        if (themeColor === "Auto") {
          themeColor = window.matchMedia && window.matchMedia("(prefers-color-scheme: dark)").matches ? "Dark" : "Light"
        } else if (!themeColor) {
          themeColor = "Light";
        }
        document.documentElement.setAttribute("data-color-scheme", themeColor.toLowerCase());
      }
      handleThemeColor();
    </script>
    {% endif %}
  {% endblock %}

  {% block app-scripts %}
  {% endblock %}

  {% if settings.FRONTEND_SENTRY_DSN %}
    <!-- Sentry -->
    <script
    src="https://browser.sentry-cdn.com/5.17.0/bundle.min.js"
    integrity="sha384-lowBFC6YTkvMIWPORr7+TERnCkZdo5ab00oH5NkFLeQUAmBTLGwJpFjF6djuxJ/5"
    crossorigin="anonymous"></script>
  {% endif %}

  <script nonce="{{request.csp_nonce}}">
    window.exports = () => {};
  </script>

  {% block page_labeling %}
    <title>Label Studio</title>
    <link href="{{settings.HOSTNAME}}{% static 'images/favicon.ico' %}" rel="shortcut icon"/>
  {% endblock %}

  {% block head %}
  {% endblock %}

  {% get_current_language as LANGUAGE_CODE %}
  {% get_available_languages as LANGUAGES %}

  <!-- Custom: hideHeader Fix Script -->
  <script nonce="{{request.csp_nonce}}">
    /**
     * Label Studio hideHeader Fix
     *
     * This script hides the header when ?hideHeader=true is present in the URL.
     * It uses CSS variable override and JavaScript to force --header-height to 0px.
     */
    (function() {
      'use strict';

      // Function to check hideHeader parameter
      function shouldHideHeader() {
        const urlParams = new URLSearchParams(window.location.search);
        return urlParams.get('hideHeader') === 'true';
      }

      /**
       * Custom Date Range Filter for Data Manager
       * Adds source_created_at date range search UI to tasks list page
       */
      function initDateRangeFilter() {
        // Only apply on project data manager page (tasks list)
        if (!window.location.pathname.match(/\/projects\/\d+\/data/)) {
          return;
        }

        // Prevent multiple initializations
        if (document.getElementById('custom-date-filter-container')) {
          return;
        }

        function createDateFilterUI() {
          const container = document.createElement('div');
          container.id = 'custom-date-filter-container';
          container.style.cssText = `
            display: inline-flex;
            align-items: center;
            gap: 8px;
            margin-left: 16px;
            padding: 4px 8px;
            background: #f5f5f5;
            border-radius: 4px;
            font-size: 13px;
          `;

          container.innerHTML = `
            <span style="color: #666; font-weight: 500;">source_created_at</span>
            <input type="date" id="date-filter-from"
                   style="padding: 4px 8px; border: 1px solid #ccc; border-radius: 4px; font-size: 13px;">
            <span style="color: #666;">~</span>
            <input type="date" id="date-filter-to"
                   style="padding: 4px 8px; border: 1px solid #ccc; border-radius: 4px; font-size: 13px;">
            <button id="date-filter-search"
                    style="padding: 6px 16px; background: #4299e1; color: white; border: none; border-radius: 4px; cursor: pointer; font-weight: 500;">
              검색
            </button>
            <button id="date-filter-clear"
                    style="padding: 6px 12px; background: #e2e8f0; color: #4a5568; border: none; border-radius: 4px; cursor: pointer; font-weight: 500;">
              초기화
            </button>
          `;

          return container;
        }

        async function applyDateFilter() {
          const fromInput = document.getElementById('date-filter-from');
          const toInput = document.getElementById('date-filter-to');

          const fromValue = fromInput.value;
          const toValue = toInput.value;

          if (!fromValue && !toValue) {
            alert('검색 기간을 입력해주세요.');
            return;
          }

          // Build filter items for Label Studio Data Manager
          const filterItems = [];

          if (fromValue) {
            // Format: YYYY-MM-DD 00:00:00 (string comparison)
            filterItems.push({
              filter: 'filter:tasks:data.source_created_at',
              operator: 'greater_or_equal',
              type: 'String',
              value: fromValue + ' 00:00:00'
            });
          }

          if (toValue) {
            // Format: YYYY-MM-DD 23:59:59 (string comparison)
            filterItems.push({
              filter: 'filter:tasks:data.source_created_at',
              operator: 'less_or_equal',
              type: 'String',
              value: toValue + ' 23:59:59'
            });
          }

          // Try to update view filters via DataManager internal API
          if (window.dataManager && window.dataManager.store) {
            try {
              const store = window.dataManager.store;
              const currentView = store.currentView;

              if (currentView) {
                // Get existing filters and merge with new date filters
                let existingFilters = [];
                if (currentView.filters) {
                  // Remove existing source_created_at filters
                  existingFilters = currentView.filters.filter(f =>
                    !f.filter || !f.filter.filter || !f.filter.filter.includes('source_created_at')
                  );
                }

                // Create new filters using DataManager's createFilter method
                // First, clear existing source_created_at filters
                if (currentView.filters) {
                  const toRemove = currentView.filters.filter(f =>
                    f.filter && f.filter.filter && f.filter.filter.includes('source_created_at')
                  );
                  for (const f of toRemove) {
                    if (typeof currentView.deleteFilter === 'function') {
                      currentView.deleteFilter(f);
                    }
                  }
                }

                // Add new date filters by updating view data directly
                const currentFiltersData = currentView.filterSnapshotRecords || [];
                const newFiltersData = currentFiltersData.filter(f =>
                  !f.filter || !f.filter.includes('source_created_at')
                );
                newFiltersData.push(...filterItems);

                // Update view via API - preserve existing data, only update filters
                const viewId = currentView.id;

                if (viewId) {
                  // First, get current view data to preserve columns and other settings
                  const getResponse = await fetch(`/api/dm/views/${viewId}/`, {
                    method: 'GET',
                    headers: {
                      'Content-Type': 'application/json',
                      'X-CSRFToken': document.cookie.match(/csrftoken=([^;]+)/)?.[1] || ''
                    }
                  });

                  if (getResponse.ok) {
                    const viewData = await getResponse.json();
                    const existingData = viewData.data || {};

                    // Update only filters, keep everything else (columns, ordering, etc.)
                    const updatedData = {
                      ...existingData,
                      filters: {
                        conjunction: 'and',
                        items: newFiltersData
                      }
                    };

                    const patchResponse = await fetch(`/api/dm/views/${viewId}/`, {
                      method: 'PATCH',
                      headers: {
                        'Content-Type': 'application/json',
                        'X-CSRFToken': document.cookie.match(/csrftoken=([^;]+)/)?.[1] || ''
                      },
                      body: JSON.stringify({
                        data: updatedData
                      })
                    });

                    if (patchResponse.ok) {
                      // Update local MobX state to match server, then reload tasks
                      try {
                        // Update filters in local state (MobX observable)
                        if (currentView.data) {
                          currentView.data.filters = updatedData.filters;
                        }

                        // Also update filterSnapshotRecords if it exists
                        if (currentView.filterSnapshotRecords !== undefined) {
                          currentView.filterSnapshotRecords.replace ?
                            currentView.filterSnapshotRecords.replace(newFiltersData) :
                            (currentView.filterSnapshotRecords = newFiltersData);
                        }

                        // Reload task data with updated filters
                        if (typeof currentView.reload === 'function') {
                          await currentView.reload();
                        }
                      } catch (syncError) {
                        console.log('[DateFilter] State sync error:', syncError);
                      }

                      console.log('[DateFilter] Filters updated via View API');
                      return;
                    }
                  }
                }
              }
            } catch (e) {
              console.log('[DateFilter] DataManager API error:', e);
            }
          }

          // Fallback: full page reload
          console.log('[DateFilter] Fallback to page reload');
          const url = new URL(window.location.href);
          const existingQuery = { filters: { conjunction: 'and', items: filterItems } };
          url.searchParams.set('query', JSON.stringify(existingQuery));
          window.location.href = url.toString();
        }

        async function clearDateFilter() {
          // Clear input fields
          const fromInput = document.getElementById('date-filter-from');
          const toInput = document.getElementById('date-filter-to');
          if (fromInput) fromInput.value = '';
          if (toInput) toInput.value = '';

          // Try to clear filters via View API
          if (window.dataManager && window.dataManager.store) {
            try {
              const store = window.dataManager.store;
              const currentView = store.currentView;

              if (currentView) {
                const viewId = currentView.id;

                if (viewId) {
                  // First, get current view data to preserve columns and other settings
                  const getResponse = await fetch(`/api/dm/views/${viewId}/`, {
                    method: 'GET',
                    headers: {
                      'Content-Type': 'application/json',
                      'X-CSRFToken': document.cookie.match(/csrftoken=([^;]+)/)?.[1] || ''
                    }
                  });

                  if (getResponse.ok) {
                    const viewData = await getResponse.json();
                    const existingData = viewData.data || {};

                    // Remove source_created_at filters, keep everything else
                    const existingFilters = existingData.filters || { conjunction: 'and', items: [] };
                    const newFiltersItems = (existingFilters.items || []).filter(f =>
                      !f.filter || !f.filter.includes('source_created_at')
                    );

                    const updatedData = {
                      ...existingData,
                      filters: {
                        conjunction: existingFilters.conjunction || 'and',
                        items: newFiltersItems
                      }
                    };

                    const patchResponse = await fetch(`/api/dm/views/${viewId}/`, {
                      method: 'PATCH',
                      headers: {
                        'Content-Type': 'application/json',
                        'X-CSRFToken': document.cookie.match(/csrftoken=([^;]+)/)?.[1] || ''
                      },
                      body: JSON.stringify({
                        data: updatedData
                      })
                    });

                    if (patchResponse.ok) {
                      // Update local MobX state to match server, then reload tasks
                      try {
                        if (currentView.data) {
                          currentView.data.filters = updatedData.filters;
                        }

                        if (currentView.filterSnapshotRecords !== undefined) {
                          currentView.filterSnapshotRecords.replace ?
                            currentView.filterSnapshotRecords.replace(newFiltersItems) :
                            (currentView.filterSnapshotRecords = newFiltersItems);
                        }

                        if (typeof currentView.reload === 'function') {
                          await currentView.reload();
                        }
                      } catch (syncError) {
                        console.log('[DateFilter] State sync error:', syncError);
                      }

                      console.log('[DateFilter] Filters cleared via View API');
                      return;
                    }
                  }
                }
              }
            } catch (e) {
              console.log('[DateFilter] DataManager API error:', e);
            }
          }

          // Fallback: full page reload
          console.log('[DateFilter] Fallback to page reload');
          window.location.reload();
        }

        function restoreDateValuesFromView() {
          // Restore date values from DataManager's current view
          // Wait for DataManager to be ready
          let checkAttempts = 0;
          const maxCheckAttempts = 30;

          const checkDataManager = setInterval(async () => {
            checkAttempts++;

            if (checkAttempts >= maxCheckAttempts) {
              clearInterval(checkDataManager);
              console.log('[DateFilter] DataManager not ready after max attempts');
              return;
            }

            if (!window.dataManager || !window.dataManager.store || !window.dataManager.store.currentView) {
              return;
            }

            clearInterval(checkDataManager);

            try {
              const currentView = window.dataManager.store.currentView;
              const viewId = currentView.id;

              // Fetch current view data from server to get saved filters
              const response = await fetch(`/api/dm/views/${viewId}/`, {
                method: 'GET',
                headers: {
                  'Content-Type': 'application/json'
                }
              });

              if (!response.ok) return;

              const viewData = await response.json();
              const filters = viewData.data?.filters;

              if (filters && filters.items && filters.items.length > 0) {
                let hasDateFilter = false;

                filters.items.forEach(item => {
                  if (item.filter && item.filter.includes('source_created_at')) {
                    hasDateFilter = true;
                    // Extract date part from "YYYY-MM-DD HH:mm:ss" format
                    const datePart = item.value ? item.value.split(' ')[0] : '';

                    if (item.operator === 'greater_or_equal' || item.operator === 'greater') {
                      const fromInput = document.getElementById('date-filter-from');
                      if (fromInput) fromInput.value = datePart;
                    } else if (item.operator === 'less_or_equal' || item.operator === 'less') {
                      const toInput = document.getElementById('date-filter-to');
                      if (toInput) toInput.value = datePart;
                    }
                  }
                });

                // If view has date filters, ensure they are applied
                if (hasDateFilter) {
                  // Update local state and reload to apply filters
                  if (currentView.data) {
                    currentView.data.filters = filters;
                  }

                  if (typeof currentView.reload === 'function') {
                    await currentView.reload();
                  }
                }
              }
            } catch (e) {
              console.log('[DateFilter] Error restoring date values:', e);
            }
          }, 200);
        }

        function insertDateFilter() {
          // Look for the toolbar row that contains Label All Tasks button
          // Find the lsf-space-dm container which is the toolbar row
          const toolbarRow = document.querySelector('.lsf-space-dm.lsf-space-dm_direction_horizontal.lsf-space-dm_size_small');

          if (!toolbarRow) {
            return false;
          }

          const filterUI = createDateFilterUI();

          // Append to the toolbar row (same line as Label All Tasks)
          toolbarRow.appendChild(filterUI);

          // Add event listeners
          document.getElementById('date-filter-search').addEventListener('click', applyDateFilter);
          document.getElementById('date-filter-clear').addEventListener('click', clearDateFilter);

          // Allow Enter key to trigger search
          document.getElementById('date-filter-from').addEventListener('keypress', function(e) {
            if (e.key === 'Enter') applyDateFilter();
          });
          document.getElementById('date-filter-to').addEventListener('keypress', function(e) {
            if (e.key === 'Enter') applyDateFilter();
          });

          // Restore date values from saved view filters and re-apply if needed
          restoreDateValuesFromView();

          return true;
        }

        // Try to insert with retry (React SPA needs time to render)
        let attempts = 0;
        const maxAttempts = 50;
        const tryInsert = setInterval(() => {
          attempts++;
          // Double-check before inserting
          if (document.getElementById('custom-date-filter-container')) {
            clearInterval(tryInsert);
            return;
          }
          if (insertDateFilter() || attempts >= maxAttempts) {
            clearInterval(tryInsert);
          }
        }, 200);
      }

      // Initialize only once using a flag
      let dateFilterInitialized = false;
      function initDateRangeFilterOnce() {
        if (dateFilterInitialized) return;
        dateFilterInitialized = true;
        initDateRangeFilter();
      }

      // Initialize date range filter after page load
      if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', initDateRangeFilterOnce);
      } else {
        initDateRangeFilterOnce();
      }

      // Monitor and apply hideHeader with very aggressive CSS
      function applyHideHeader() {
        const hideHeader = shouldHideHeader();

        if (hideHeader) {
          // Add CSS to hide the header with very aggressive selectors
          if (!document.getElementById('hide-header-style')) {
            const style = document.createElement('style');
            style.id = 'hide-header-style';
            style.textContent = `
              /* Override CSS variable to remove header height from calculations */
              /* This fixes the bottom spacing issue when header is hidden */
              :root {
                --header-height: 0px !important;
              }

              html {
                --header-height: 0px !important;
              }

              body {
                --header-height: 0px !important;
              }

              * {
                --header-height: 0px !important;
              }

              /* Hide ONLY the main menu header - Label Studio specific */
              .lsf-menu-header {
                display: none !important;
                visibility: hidden !important;
                opacity: 0 !important;
                height: 0 !important;
                min-height: 0 !important;
                overflow: hidden !important;
                padding: 0 !important;
                margin: 0 !important;
              }
            `;

            document.head.appendChild(style);
          }
        }
      }

      // Force CSS variable to 0 continuously
      function forceHeaderHeightToZero() {
        if (shouldHideHeader()) {
          document.documentElement.style.setProperty('--header-height', '0px', 'important');
          if (document.body) {
            document.body.style.setProperty('--header-height', '0px', 'important');
          }
        }
      }

      // Apply immediately
      applyHideHeader();
      forceHeaderHeightToZero();

      // Apply on DOM ready
      if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', () => {
          applyHideHeader();
          forceHeaderHeightToZero();
        });
      }

      // Apply after window load (React app fully loaded)
      window.addEventListener('load', function() {
        applyHideHeader();
        forceHeaderHeightToZero();
      });

      // Force the CSS variable every 100ms for the first 5 seconds
      // This ensures it stays 0px even if Label Studio's CSS tries to override it
      if (shouldHideHeader()) {
        let count = 0;
        const intervalId = setInterval(() => {
          forceHeaderHeightToZero();
          count++;
          if (count >= 50) { // 50 * 100ms = 5 seconds
            clearInterval(intervalId);
          }
        }, 100);
      }

      // Also observe for dynamic content changes (React SPA)
      let observerApplied = false;
      const observer = new MutationObserver(() => {
        if (shouldHideHeader() && !observerApplied) {
          applyHideHeader();
          forceHeaderHeightToZero();
          observerApplied = true;
        }
      });

      observer.observe(document.documentElement, {
        childList: true,
        subtree: true
      });
    })();
  </script>

</head>

<body>

<div class="app-wrapper"></div>

<template id="main-content">
  <main class="main">

    <!-- Space & Divider -->
    {% block divider %}
      <div class="ui divider divider-wide"></div>
    {% endblock %}

    <!-- Content -->
    {% block content %}
    {% endblock %}

  </main>
</template>

<template id="context-menu-left">
  {% block context_menu_left %}{% endblock %}
</template>

<template id="context-menu-right">
  {% block context_menu_right %}{% endblock %}
</template>

<script id="app-settings" nonce="{{request.csp_nonce}}">
  window.APP_SETTINGS = Object.assign({
    user: {
      id: {{ user.pk }},
      username: "{{user.username}}",
      firstName: "{{user.first_name}}",
      lastName: "{{user.last_name}}",
      initials: "{{user.get_initials}}",
      email: "{{user.email}}",
      allow_newsletters: {% if user.allow_newsletters is None %}null{% else %}{{user.allow_newsletters|yesno:"true,false"}}{% endif %},
      {% if user.avatar %}
      avatar: "{{user.avatar_url|safe}}",
      {% endif %}
    },
    debug: {{settings.DEBUG|yesno:"true,false"}},
    hostname: "{{settings.HOSTNAME}}",
    version: {{ versions|json_dumps_ensure_ascii|safe }},
    sentry_dsn: {% if settings.FRONTEND_SENTRY_DSN %}"{{ settings.FRONTEND_SENTRY_DSN }}"{% else %}null{% endif %},
    sentry_rate: "{{ settings.FRONTEND_SENTRY_RATE }}",
    sentry_environment: "{{ settings.FRONTEND_SENTRY_ENVIRONMENT }}",
    editor_keymap: JSON.parse({{ settings.EDITOR_KEYMAP|safe }}),
    feature_flags: {{ feature_flags|json_dumps_ensure_ascii|safe }},
    feature_flags_default_value: {{ settings.FEATURE_FLAGS_DEFAULT_VALUE|json_dumps_ensure_ascii|safe }},
    server_id: {{ request.server_id|json_dumps_ensure_ascii|safe }},
    collect_analytics: {{ settings.COLLECT_ANALYTICS|yesno:"true,false" }},

    {% block app_more_settings %}
      flags: {
        allow_organization_webhooks: {{settings.ALLOW_ORGANIZATION_WEBHOOKS|yesno:"true,false"}},
        storage_persistence: {{ settings.STORAGE_PERSISTENCE|yesno:"true,false" }},
      },
    {% endblock %}

  }, {% block frontend_settings %}{}{% endblock %});
</script>

{% block app-js %}
<script src="{{settings.FRONTEND_HOSTNAME}}/react-app/runtime.js?v={{ versions.backend.commit }}"></script>
{% comment %}
  NOTE: purposely setting this to not cache using backend commit as we do not intend this to change frequently.
  If for any reason we need to invalidate the cache, we can do so by changing the version number.
{% endcomment %}
<script src="{{settings.FRONTEND_HOSTNAME}}/react-app/vendor.js?v=1"></script>
<script src="{{settings.FRONTEND_HOSTNAME}}/react-app/main.js?v={{ versions.backend.commit }}"></script>
{% endblock %}

{% block bottomjs %}
  <script src="{{settings.HOSTNAME}}{% static 'js/jquery.min.js' %}"></script>
  <script nonce="{{request.csp_nonce}}">

    // CSRF
    (function() {
      function csrfSafeMethod(method) {
        // these HTTP methods do not require CSRF protection
        return (/^(GET|HEAD|OPTIONS|TRACE)$/.test(method));
      }

      // Apply CSRF token
      var csrftoken = jQuery("[name=csrfmiddlewaretoken]").val();
      $.ajaxSetup({
        beforeSend: function (xhr, settings) {
          if (!csrfSafeMethod(settings.type) && !this.crossDomain) {
            xhr.setRequestHeader("X-CSRFToken", csrftoken);
          }
        }
      });
    })();

  </script>
{% endblock %}

<div id="dynamic-content">

  {% block billing-checks %}
  {% endblock %}

</div>

</body>
</html>
